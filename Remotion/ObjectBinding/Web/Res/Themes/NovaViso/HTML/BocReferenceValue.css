/* Style applied to the BocReferenceValue. */

.bocReferenceValue
{
  --bocReferenceValue-input-width: 100%;
  --bocReferenceValue-options-menu-width: 100%;
  min-height: var(--remotion-themed-singleline-min-height);
  display: flex;
}

.bocReferenceValue span.body
{
  display: inline-grid;
  grid-template-areas: "content optionsMenu";
  grid-template-columns: minmax(var(--remotion-themed-control-width-half), var(--remotion-themed-control-width)) 1fr;
  gap: var(--remotion-themed-spacing);
  align-items: center;
}

.bocReferenceValue span.icon
{
  grid-area: content;
}

.bocReferenceValue span.icon img
{
  position: relative;
  width: var(--default-icon-size);
  height: var(--default-icon-size);
  padding-left: calc(var(--remotion-themed-spacing) + var(--remotion-themed-border-width));
  pointer-events: none;

  /* Currently used for overriding img.Icon rule in Style.css. */
  vertical-align: top;
}

.bocReferenceValue span.content
{
  grid-row: 1;
  grid-column: content;
  display: inline-flex;
}

.bocReferenceValue span.content select
{
  width: var(--bocReferenceValue-input-width);
}

.mozilla .bocReferenceValue span.content select
{
  padding-top: revert;
}

.bocReferenceValue span.content.hasIcon select
{
  padding-left: calc(var(--default-icon-size) + var(--remotion-themed-spacing));
}

.bocReferenceValue span.content select.error
{
  background-image: url('../Image/sprite.svg#ReferenceValueErrorIndicator');
  background-size: var(--remotion-themed-line-height);
  background-position: right var(--remotion-themed-img-width) center;
  background-repeat: no-repeat;
}

.bocReferenceValue span.content select option
{
  padding: var(--remotion-themed-spacing-small) auto;
}

.bocReferenceValue.disabled:not(.readOnly) span.content
{
  color: var(--color-disabled-text);
  cursor: default;
}

.bocReferenceValue.readOnly span.body > span.icon
{
  align-self: start;
  padding: var(--remotion-themed-control-padding-readonly);
  padding-right: 0;
  padding-bottom: 0;
  padding-left: 0;
  border: var(--remotion-themed-border-readonly);
}

.bocReferenceValue.readOnly span[tabindex]
{
  min-height: var(--remotion-themed-singleline-min-height);
  box-sizing: border-box;
  display: flex;
  align-items: center;
  padding: var(--remotion-themed-control-padding-readonly);
  border: var(--remotion-themed-border-readonly);
  border-radius: var(--remotion-themed-border-radius);
}

.bocReferenceValue.readOnly span[tabindex]:focus-visible
{
  outline: none;
  border: var(--remotion-themed-border-readonly-focus);
  background-color: var(--remotion-themed-background-color-readonly-focus);
  box-shadow: var(--remotion-themed-box-shadow-readonly-focus);
}

span.bocReferenceValue.readOnly span[tabindex]:empty
{
  /* Ensures that the keyboard focus of empty readonly values surrounds the entires width of the span. */
  width: 100%;
}

span.bocReferenceValue.readOnly span[tabindex]:empty:before
{
  /* Inserting a 'zero width space' unicode character as placeholder so that empty
  readonly values are not collapsed and can therefore visualize the keyboard focus.
  This also scales with the font size and min-height doesn't have to be set since
  line height remains unchanged. */
  content: "\200b";
}

.bocReferenceValue.readOnly span.content.hasIcon span
{
  padding-left: calc(var(--default-icon-size) + var(--remotion-themed-spacing));
}

.bocReferenceValue span.optionsMenu
{
  grid-area: optionsMenu;
}

.bocReferenceValue span.optionsMenu span span.DropDownMenuSelect
{
  width: var(--bocReferenceValue-options-menu-width);
}
// This file is part of the re-motion Core Framework (www.re-motion.org)
// Copyright (c) rubicon IT GmbH, www.rubicon.eu
//
// The re-motion Core Framework is free software; you can redistribute it
// and/or modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1 of the
// License, or (at your option) any later version.
//
// re-motion is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with re-motion; if not, see http://www.gnu.org/licenses.
//
#if !NETFRAMEWORK
using System;
using System.Diagnostics.CodeAnalysis;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Rewrite;
using Remotion.Utilities;

namespace Remotion.Web.Resources;

/// <summary>
/// ASP.NET Core rewrite rule that removes the cache key generated by <see cref="ResourcePathBuilderBasedStaticResourceCacheKeyProvider"/> from the URL.
/// The URL is rewritten and the cache key is made available to any further middleware.
/// </summary>
/// <seealso cref="CachingApplicationBuilderExtensions.UseRemotionStaticFiles"/>
/// <remarks>
/// The preferred way of using this rewrite rule is using <see cref="CachingApplicationBuilderExtensions"/>.<see cref="CachingApplicationBuilderExtensions.UseRemotionStaticFiles"/>.
/// </remarks>
public class RemotionStaticFilesCacheKeyRemovalRewriteRule : IRule
{
  private const string c_cacheKeyUrlIdentifier = "/cache_";
  private const string c_removedCacheKeyItemsKey = "RemotionRemovedCacheKey";

  /// <summary>
  /// Tries to retrieve a cache key from <paramref name="context"/>, which was previously removed using <see cref="RemotionStaticFilesCacheKeyRemovalRewriteRule"/>.
  /// The cache key matches the value returned by <see cref="IStaticResourceCacheKeyProvider"/>.
  /// </summary>
  public static bool TryGetRemovedCacheKey (HttpContext context, [NotNullWhen(true)] out string? cacheKey)
  {
    if (context.Items.TryGetValue(c_removedCacheKeyItemsKey, out var removedCacheKeyObject) && removedCacheKeyObject is string removedCacheKeyString)
    {
      cacheKey = removedCacheKeyString;
      return true;
    }

    cacheKey = default;
    return false;
  }

  private readonly PathString _requestPath;
  private readonly bool _stopProcessing;

  public RemotionStaticFilesCacheKeyRemovalRewriteRule (PathString requestPath, bool stopProcessing)
  {
    if (!requestPath.HasValue)
      throw new ArgumentException("Request path must have a value.", nameof(requestPath));
    if (requestPath.Value.EndsWith('/'))
      throw new ArgumentException("Request path must not end in a slash.", nameof(requestPath));

    _requestPath = requestPath;
    _stopProcessing = stopProcessing;
  }

  /// <inheritdoc />
  public void ApplyRule (RewriteContext context)
  {
    ArgumentUtility.CheckNotNull(nameof(context), context);

    var httpContext = context.HttpContext;
    if (TryMatchPath(httpContext, out var newRequestPath, out var cacheKey))
    {
      httpContext.Request.Path = newRequestPath;
      httpContext.Items.Add(c_removedCacheKeyItemsKey, cacheKey);

      if (_stopProcessing)
        context.Result = RuleResult.SkipRemainingRules;
    }
  }

  private bool TryMatchPath (
      HttpContext context,
      [NotNullWhen(true)] out string? newRequestPath,
      [NotNullWhen(true)] out string? cacheKey)
  {
    var requestPath = context.Request.Path;
    newRequestPath = default;
    cacheKey = default;

    var requestPathEndsWithSlash = requestPath.HasValue && !requestPath.Value.EndsWith('/');
    var requestPathWithTrailingSlash = requestPathEndsWithSlash
        ? requestPath
        : requestPath + new PathString("/");

    if (!requestPathWithTrailingSlash.StartsWithSegments(_requestPath, out var remaining))
      return false;

    if (!remaining.HasValue)
      return false;

    var remainingRequestPath = remaining.Value;
    if (!remainingRequestPath.StartsWith(c_cacheKeyUrlIdentifier))
      return false;

    var indexOfSlash = remainingRequestPath.IndexOf('/', c_cacheKeyUrlIdentifier.Length);

    // This should be impossible as we appended a slash earlier -> treat as no match to be defensive
    if (indexOfSlash == -1)
      return false;

    var remainingPath = requestPathEndsWithSlash
        ? remainingRequestPath[indexOfSlash..]
        : remainingRequestPath[indexOfSlash..^1];

    // If we added a trailing slash to the cache identifier, we might get an empty string here.
    // e.g. '/wwwroot/cache_ab' would lead to an empty restPath. In such a case, we want to use
    // a slash instead to get '/wwwroot/' as new request path.
    if (remainingPath.Length == 0)
      remainingPath = "/";

    newRequestPath = _requestPath + remainingPath;
    cacheKey = remainingRequestPath[c_cacheKeyUrlIdentifier.Length..indexOfSlash];
    return true;
  }
}
#endif
